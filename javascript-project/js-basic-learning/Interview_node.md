<!--
 * @Author: TerryMin
 * @Date: 2025-01-07 11:13:52
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-03-15 12:15:14
 * @Description: file not
-->

# Nodejs

## [webpack](https://webpack.js.org/)

- webpack 与 vite 区别？

  1. 设计理念:
     1.1 Webpack 是一个高度可配置的模块打包工具，它采用的是 “打包优先” 的理念。它把所有资源（如 JavaScript、CSS、图片等）都视为模块，通过各种 loader 和 plugin 对这些模块进行处理和转换，最终将它们打包成一个或多个静态文件。
     1.2 Vite 秉持 “服务优先” 的理念，利用现代浏览器原生支持 ES 模块的特性，在开发阶段无需打包，直接以原生 ESM 方式提供源码。只有在生产环境下才进行打包，这样可以显著提高开发服务器的启动速度和热更新速度。

  2. 构建速度:
     2.1 webpack 需要对整个项目进行打包,将所有模块进行解析、转换和合并,这个过程由于会涉及大量文件读写和计算操作,因此启动时间较长
     2.2 Vite 利用 esbuild 进行预打包和依赖解析，首次启动和热更新速度快。在开发环境下无需打包，当浏览器请求某个模块时，Vite 才会对该模块进行即时编译。

  3. 生态系统:
     3.1 Webpack 诞生较早，拥有庞大的生态系统。有大量的 loader 和 plugin 可供选择，可以满足各种复杂的项目需求。
     3.2 Vite 的生态系统在不断发展壮大，但目前相对 Webpack 来说还不够成熟。

  4. 配置复杂度:
     4.1 Webpack 的配置非常灵活和强大，但也相对复杂。需要配置多个方面
     4.2 Vite 的配置相对简单，默认情况下已经提供了很多合理的配置

- 前端工程化的理解

  1. 工程化目标
     1.1 提高开发效率：通过自动化工具和流程，减少重复劳动，例如使用脚手架工具快速搭建项目结构，使用构建工具自动处理代码压缩、合并等任务。
     1.2 保证代码质量：借助代码规范、代码检查工具（如 ESLint、Prettier）和单元测试框架（如 Jest、Mocha），确保代码符合统一的风格和标准，减少潜在的错误和漏洞。
     1.3 增强项目的可维护性：采用模块化开发思想，将代码拆分成独立的模块，降低代码的耦合度，方便后续的修改和扩展。
     1.4 优化项目部署：通过自动化部署工具，实现代码的快速、稳定部署，减少人工操作带来的风险和错误，确保项目能够及时上线。

  2. 工程化的主要内容
     2.1 模块化开发:代码模块化：将一个大型的前端项目拆分成多个小的、独立的模块，每个模块负责特定的功能。资源模块化：不仅代码可以模块化，图片、字体等资源也可以进行模块化管理。
     2.2 组件化开发：将页面中可复用的部分封装成组件，采用组件化架构可以提高开发效率和代码的可维护性。
     2.3 构建工具：打包和压缩、代码转换、资源处理。
     2.4 代码规范和检查
     2.5 持续集成和持续部署（CI/CD）：在开发过程中，频繁地将代码集成到主干分支，并进行自动化测试和构建。通过持续集成，可以及时发现代码合并带来的冲突和问题，保证代码的质量。常见的持续集成工具如 Jenkins、GitLab CI/CD 等。

## [Vite](https://cn.vite.dev/)

- Vite 打包原理:

  1.  开发阶段:
      1.1 基于原生 ES 模块（ESM）:Vite 利用现代浏览器对原生 ES 模块的支持，在开发阶段直接以 ESM 的方式提供模块。当启动开发服务器时，Vite 会拦截浏览器的请求，将项目中的模块以 ESM 的格式返回给浏览器。
      1.2 按需加载模块:Vite 采用按需加载策略，只有当浏览器请求某个模块时，Vite 才会对该模块进行处理和编译。
      1.3 快速热更新（HMR）:Vite 的 HMR 功能可以在代码发生变化时，只更新发生变化的模块，而不需要重新加载整个页面。

  2.  生产阶段:
      2.1 构建优化: 在生产环境中，Vite 会使用 Rollup 进行打包。Rollup 是一个 JavaScript 模块打包工具，它可以将多个模块打包成一个或多个文件，以减少浏览器的请求次数。
      Vite 在打包过程中会对代码进行优化，包括压缩代码、去除死代码、合并文件等操作，以减小文件体积，提高页面加载速度。

      2.2 静态资源处理:Vite 会对项目中的静态资源（如图片、字体等）进行处理。对于较小的图片，Vite 可以将其转换为 Base64 编码，直接嵌入到 HTML 或 CSS 文件中，减少请求次数；对于较大的图片，Vite 会对其进行压缩和优化，并生成相应的文件名哈希，以利用浏览器的缓存机制。

      2.3 代码分割:Vite 支持代码分割，将应用程序分割成多个较小的文件，实现按需加载。这样可以避免一次性加载整个应用程序，提高首屏加载速度。例如，对于路由组件，Vite 可以将其分割成独立的文件，当用户访问相应的路由时再加载对应的组件。

      2.4 缓存机制
      2.4.1 文件系统缓存:Vite 会对处理过的模块进行缓存，当再次处理相同的模块时，可以直接从缓存中读取，避免了重复的处理过程。这在项目规模较大或者频繁修改代码时，能够显著提高打包速度。
      2.4.2 浏览器缓存：Vite 会为打包后的文件生成唯一的文件名哈希，利用浏览器的缓存机制，当文件内容没有变化时，浏览器可以直接从缓存中加载文件，减少了不必要的网络请求。

  3.  注意:
      3.1 原生 ES 模块（ESM）:JavaScript 原生 ES 模块（ES Modules）是 ECMAScript 2015（ES6）引入的一种模块系统，用于在 JavaScript 中实现模块化编程。在 ES 模块出现之前，JavaScript 没有内置的模块系统，开发者通常使用 CommonJS（用于 Node.js）、AMD（如 RequireJS）等第三方模块规范来实现模块化

- Vite 插件及开发

  1.  定义:Vite 本身支持常见的 JavaScript、CSS、JSON 等文件类型，但对于一些特殊的文件类型，如 .vue、.jsx、.ts 等，需要借助插件来处理。Vite 插件通过扩展 Vite 的功能，为开发者提供了更多的灵活性和便利性，使得 Vite 能够适应各种不同的项目需求。
  2.  Vite 插件开发:[Vite 写一个插件](https://juejin.cn/post/7075678169122439181)

## Http

- [Http 三次握手与四次挥手](https://www.cnblogs.com/terrymin/p/14554404.html)

  1. 三次握手与四次挥手:一般是发生在用户在浏览器输入 URL 地址后,经过 DNS 域名解析返回 IP 地址,然后通过三次握手建立 Http 与 TCP 的链接。资源加载完后再进行四次挥手操作。

- [ Http2.0 与 Http1.1 区别](https://www.cnblogs.com/terrymin/articles/14010138.html)

  1. 新的二进制格式：二进制协议，不再是纯文本；将请求和响应拆分为更小的二进制帧进行传输，提高了传输效率和解析速度。
  2. 多路复用：HTTP1.1 的连接是串行的,同一时间只能发送一个请求,新的请求必须等待前一个请求完成。HTTP2 允许同时发送多个请求和响应，每个被分成多个帧，并带有唯一的流 ID，这些帧可以乱序发送，接收方根据流 ID 重新组装。多路复用提高了连接的利用率，减少了延迟和头部阻塞的问题。
  3. header 压缩：使用专用算法压缩头部，减少数据传输量；
  4. 服务端推送：允许服务器向客户端推送数据；
  5. 增强了安全性，要求通信加密；

  - HTTP 与 TCP 关系:
    1. TCP: 属于传输层协议，主要负责在不同主机的应用程序之间提供可靠的数据传输服务。它通过端口号来标识不同的应用程序，实现了端到端的数据传输。
    2. HTTP: 属于应用层协议，主要负责规定客户端和服务器之间数据交互的格式和规则，定义了如何发起请求、如何发送和接收数据以及如何处理响应等。
    3. HTTP（超文本传输协议）和 TCP（传输控制协议）:是计算机网络中不同层次的协议，它们之间存在着紧密的关系，共同为网络数据传输和应用层通信提供支持
    4. HTTP 依赖 TCP 的连接管理: TCP 负责连接的建立、维护和关闭。在 HTTP 通信中，客户端与服务器之间的每次交互通常都依赖于 TCP 连接。

- HTTP3 有哪些新特性

  1.  基于 QUIC （Quick UDP Internet Connections）协议：QUIC 协议在 UDP 之上构建，结合了 TCP 的可靠性和 UDP 的低延迟特性，解决了 TCP 连接中的队头阻塞问题。
  2.  更快的连接建立：QUIC 协议在建立连接时减少了握手次数，能够更快地建立连接，特别是在移动网络环境下，提高了连接的稳定性和速度。
  3.  更好的拥塞控制：QUIC 协议提供了更灵活和高效的拥塞控制机制，能够根据网络状况动态调整数据传输速率，优化网络性能。

  - QUIC（Quick UDP Internet Connections）协议和 UDP（User Datagram Protocol）:

    1.  QUIC（Quick UDP Internet Connections）协议和 UDP（User Datagram Protocol）均属于传输层协议
    2.  QUIC 协议：它是 UDP 协议的增强版本，在保留 UDP 低延迟特点的基础上，增加了可靠性、安全性和多路复用等功能，主要应用于 HTTP/3 协议。
    3.  UDP（User Datagram Protocol）协议：是一种轻量级的传输协议，速度快但缺乏可靠性保障，适用于实时性要求高且能接受数据丢失的场景。

- 常见 HTTP 状态码:

  1.  204 No Content: 服务器成功处理了请求,不需要返回内容。
  2.  301 Moved Permanently: 请求的资源已被永久移到新的 URL。
  3.  302 Found: 请求资源临时移到了新的 URL。
  4.  401 Unauthorized:客户端需要进行身份验证才能访问请求的资源。
  5.  403 Forbidden:客户端具有访问资源权限,但服务器拒绝了请求。
  6.  404 Not Found: 资源未找到
  7.  500 Internal Server Error：服务器内部发生了未知的错误，导致无法处理请求。
  8.  502 Bad Gateway: 服务器作为网关,上游服务求出现故障。
  9.  503 Service Unavailable: 服务器暂时不可用。

- [浏览器强缓存与协商缓存](https://www.cnblogs.com/terrymin/p/13717855.html)

  1. 缓存访问顺序:网络请求优先访问强缓存,如果失效再访问协商缓存,如果失效发起网络请求。

- [应用资源缓存 PWA](https://segmentfault.com/a/1190000041564624)

  1. PWA（Progressive Web Apps）不是特指某一项技术，而是应用多项技术来改善用户体验的 Web App，为 Web App 提供类似 Native App 的用户体验。其核心技术包括 Web App Manifest，Web Push，Service Worker 和 Cache Api 等，用户体验才是 PWA 的核心。

  2. PWA 主要特点如下：

     - 可靠 - 即使在网络不稳定甚至断网的环境下，也能瞬间加载并展现
     - 用户体验 - 快速响应，具有平滑的过渡动画及用户操作的反馈
     - 用户黏性 - 和 Native App 一样，可以被添加到桌面，能接受离线通知，具有沉浸式的用户体验

  3. 缓存
     3.1 应用缓存(Application Cache):用于存储静态资源(缓存应用程序)。
     3.2 Service Worker 本质上是充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器，独立于网页主进程。它可以拦截网络请求，实现离线支持、消息推送、后台同步等功能，为 Web 应用带来类似原生应用的用户体验。逐渐成为了 Application Cache 的替代方案。

- 跨域:

  1.  定义: 跨域是指在浏览器中从一个域名地址的网页去请求另一个域名的资源时，由于浏览器的同源策略，会导致请求被限制的情况。同源策略是浏览器的一种安全机制，它要求网页的协议、域名和端口都相同才被认为是同源，只有同源的页面之间才能进行自由的资源共享和交互。

  2.  原因: 浏览器的同源策略是跨域问题产生的根本原因。同源策略的目的是为了防止不同源的网站之间进行恶意的脚本攻击，比如防止一个网站通过脚本读取另一个网站的敏感信息。

  3.  跨域解决方法:
      3.1 JSONP（JSON with Padding）原理：JSONP 是一种古老的跨域解决方案，它利用了 <script> 标签的 src 属性不受同源策略限制的特点。优点：兼容性好，几乎所有的浏览器都支持。

      3.2 CORS（Cross-Origin Resource Sharing）原理：CORS 是一种现代的跨域解决方案，它是 W3C 标准，允许浏览器和服务器进行跨域通信。当浏览器发起跨域请求时，会在请求头中添加一个 Origin 字段，用于标识请求的来源。服务器收到请求后，会根据自身的配置，在响应头中添加 Access-Control-Allow-Origin 等相关字段，来告诉浏览器是否允许该跨域请求。优点：支持所有的 HTTP 请求方法，是 W3C 标准，安全性高。缺点：需要服务器端进行配置，对于一些旧版本的浏览器可能不支持。

      3.3 代理服务器 原理：代理服务器是一种在服务器端进行跨域请求的解决方案。在开发环境中，可以使用开发服务器（如 Webpack Dev Server、Vite 等）的代理功能，将前端的请求转发到目标服务器。在生产环境中，可以使用 Nginx 等服务器软件作为代理服务器，将客户端的请求转发到后端服务器，从而绕过浏览器的同源策略。优点：可以在服务器端进行统一的跨域处理，不需要在前端进行额外的配置。缺点：需要额外的服务器资源，增加了系统的复杂性。

      3.4 注意: 前端通过代理方式解决跨域的原因:是利用了服务器之间不受同源策略限制的特点，通过代理服务器转发请求，从而绕过了浏览器的跨域限制。

- 基于 HTTP 定时器更新、SSE、WebScoket 之间区别(数据实时通信更新方案)

  1.  基于 HTTP 定时器更新:定时器更新页面数据是基于客户端的一种主动轮询机制。通过使用 setInterval 或 setTimeout 函数，客户端按照预设的时间间隔向服务器发送请求，获取最新的数据并更新页面 适用于数据更新频率较低、对实时性要求不高的场景。例如，一些静态网站的新闻列表更新、博客文章的点赞数统计等。
      1.1 HTTP 是半双工的，通常是客户端发起请求，服务器响应请求。

  2.  SSE（Server-Sent Events）是一种允许服务器向客户端实时推送更新数据的 Web 技术，它基于 HTTP 协议，使用简单，适合实现服务器端向客户端的单向实时数据传输，比如股票行情更新、新闻推送等场景。
      2.1 优点:
      简单易用：基于 HTTP 协议，不需要复杂的握手过程，使用起来非常简单。
      自动重连：当连接断开时，客户端会自动尝试重新连接，保证数据的连续性。
      文本格式：数据以文本格式传输，易于解析和处理。
      2.2 局限性:
      单向通信：只能由服务器向客户端发送数据，客户端不能向服务器发送数据。
      浏览器兼容性：虽然现代浏览器大多支持 SSE，但在一些旧版本的浏览器中可能存在兼容性问题。

  3.  WebScoket 是一种在单个 TCP 连接上进行全双工通信的协议，它使得客户端和服务器之间能够进行实时、双向的数据传输，适用于实时聊天、多人协作、实时数据的更新、游戏开发。
      3.1 优点:
      实时性高：全双工通信和持久连接使得数据能够实时传输，减少了延迟。
      节省资源：避免了频繁建立和断开连接的开销，降低了服务器和客户端的资源消耗。
      支持多种数据格式：可以传输文本和二进制数据，满足不同的应用需求。
      3.2 缺点:
      实现复杂度较高：需要处理连接的建立、关闭、错误等多种状态，开发和维护成本相对较高。
      安全性要求高：由于 WebSocket 连接是持久的，一旦被攻击，可能会导致数据泄露或服务中断，因此需要加强安全防护。

## Nodejs

- CommonJS 与 ES6 Module 规范的区别：

  1.  CommonJS 是同步加载，ESM 是异步加载；(由于 CommonJS 是用于服务器端的模块体系，需要加载的模块都在本地，所以采用同步加载也不会出问题，但是 ESM 用于浏览器端时，可能涉及到一些异步请求，所以需要采用异步加载。)
  2.  CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口。
  3.  ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、filename、dirname。
  4.  CommonJS 输出是值的浅拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变。
  5.  CommonJs 导入的模块路径可以是一个表达式，因为它使用的是 require()方法；而 ES6 Modules 只能是字符串。
  6.  CommonJSthis 指向当前模块，ES6 Modulesthis 指向 undefined。
