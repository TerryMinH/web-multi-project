<!--
 * @Author: TerryMin
 * @Date: 2025-01-07 11:13:52
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-03-06 18:45:05
 * @Description: file not
-->

# Nodejs

## [webpack](https://webpack.js.org/)

- webapck 中 plugins 和 loader 的区别?

  1.  Loader 与 Plugin 区别:

      1.1 作用不同:
      1.1.1 Loader: webpack 默认只能打包处理 JS 文件，或者 JS 模块。但是像 CSS 模块和图片模块需要 loader 工具处理；loader 就是打包那些 webpack 默认打包不了的模块的工具。
      1.1.2 Plugin：可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

      1.2 用法不同:
      1.2.1 Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。
      1.2.2 Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。

- webpack 常用 loader?

  1. url-loader:它与 file-loader 作用相似，也是处理图片的，只不过 url-loader 可以设置一个根据图片大小进行不同的操作，如果该图片大小大于指定的大小，则将图片进行打包资源，否则将图片转换为 base64 字符串合并到 js 文件里。
  2. style-loader:通过注入\<style\>标签将 CSS 插入到 DOM 中
  3. css-loader:仅处理 css 的各种加载语法(@import 和 url()函数等),就像 js 解析 import/require() 一样
  4. less-loader:解析 less，转换为 css

- webpack 插件如何编写?

## [Vite](https://cn.vite.dev/)

- Vite 打包原理:

  1.  开发阶段:
      1.1 基于原生 ES 模块（ESM）:Vite 利用现代浏览器对原生 ES 模块的支持，在开发阶段直接以 ESM 的方式提供模块。当启动开发服务器时，Vite 会拦截浏览器的请求，将项目中的模块以 ESM 的格式返回给浏览器。
      1.2 按需加载模块:Vite 采用按需加载策略，只有当浏览器请求某个模块时，Vite 才会对该模块进行处理和编译。
      1.3 快速热更新（HMR）:Vite 的 HMR 功能可以在代码发生变化时，只更新发生变化的模块，而不需要重新加载整个页面。

  2.  生产阶段:
      2.1 构建优化: 在生产环境中，Vite 会使用 Rollup 进行打包。Rollup 是一个 JavaScript 模块打包工具，它可以将多个模块打包成一个或多个文件，以减少浏览器的请求次数。
      Vite 在打包过程中会对代码进行优化，包括压缩代码、去除死代码、合并文件等操作，以减小文件体积，提高页面加载速度。

      2.2 静态资源处理:Vite 会对项目中的静态资源（如图片、字体等）进行处理。对于较小的图片，Vite 可以将其转换为 Base64 编码，直接嵌入到 HTML 或 CSS 文件中，减少请求次数；对于较大的图片，Vite 会对其进行压缩和优化，并生成相应的文件名哈希，以利用浏览器的缓存机制。

      2.3 代码分割:Vite 支持代码分割，将应用程序分割成多个较小的文件，实现按需加载。这样可以避免一次性加载整个应用程序，提高首屏加载速度。例如，对于路由组件，Vite 可以将其分割成独立的文件，当用户访问相应的路由时再加载对应的组件。

      2.4 缓存机制
      2.4.1 文件系统缓存:Vite 会对处理过的模块进行缓存，当再次处理相同的模块时，可以直接从缓存中读取，避免了重复的处理过程。这在项目规模较大或者频繁修改代码时，能够显著提高打包速度。
      2.4.2 浏览器缓存：Vite 会为打包后的文件生成唯一的文件名哈希，利用浏览器的缓存机制，当文件内容没有变化时，浏览器可以直接从缓存中加载文件，减少了不必要的网络请求。

  3.  注意:
      3.1 原生 ES 模块（ESM）:JavaScript 原生 ES 模块（ES Modules）是 ECMAScript 2015（ES6）引入的一种模块系统，用于在 JavaScript 中实现模块化编程。在 ES 模块出现之前，JavaScript 没有内置的模块系统，开发者通常使用 CommonJS（用于 Node.js）、AMD（如 RequireJS）等第三方模块规范来实现模块化

- Vite 插件及开发

  1.  定义:Vite 本身支持常见的 JavaScript、CSS、JSON 等文件类型，但对于一些特殊的文件类型，如 .vue、.jsx、.ts 等，需要借助插件来处理。Vite 插件通过扩展 Vite 的功能，为开发者提供了更多的灵活性和便利性，使得 Vite 能够适应各种不同的项目需求。
  2.  Vite 插件开发:[Vite 写一个插件](https://juejin.cn/post/7075678169122439181)

- webpack 与 vite 区别？

  1. 设计理念:
     1.1 Webpack 是一个高度可配置的打包工具，它采用的是 “打包优先” 的理念。它把所有资源（如 JavaScript、CSS、图片等）都视为模块，通过各种 loader 和 plugin 对这些模块进行处理和转换，最终将它们打包成一个或多个静态文件。
     1.2 Vite 秉持 “服务优先” 的理念，利用现代浏览器原生支持 ES 模块的特性，在开发阶段无需打包，直接以原生 ESM 方式提供源码。只有在生产环境下才进行打包，这样可以显著提高开发服务器的启动速度和热更新速度。

  2. 构建速度:
     2.1 webpack 需要对整个项目进行打包,将所有模块进行解析、转换和合并,这个过程由于会涉及大量文件读写和计算操作,因此启动时间较长
     2.2 Vite 在开发环境下无需打包，当浏览器请求某个模块时，Vite 才会对该模块进行即时编译。由于只处理当前请求的模块，所以启动速度极快，通常只需几秒钟

  3. 生态系统:
     3.1 Webpack 诞生较早，拥有庞大的生态系统。有大量的 loader 和 plugin 可供选择，可以满足各种复杂的项目需求。
     3.2 Vite 的生态系统在不断发展壮大，但目前相对 Webpack 来说还不够成熟。

  4. 配置复杂度:
     4.1 Webpack 的配置非常灵活和强大，但也相对复杂。需要配置多个方面
     4.2 Vite 的配置相对简单，默认情况下已经提供了很多合理的配置

## Http

- [Http 三次握手与四次挥手](https://www.cnblogs.com/terrymin/p/14554404.html)

  1. 三次握手与四次挥手:一般是发生在用户在浏览器输入 URL 地址后,经过 DNS 域名解析返回 IP 地址,然后通过三次握手建立 Http 与 TCP 的链接。资源加载完后再进行四次挥手操作。

- [ Http2.0 与 Http1.1 区别](https://www.cnblogs.com/terrymin/articles/14010138.html)

  1. 新的二进制格式：二进制协议，不再是纯文本；
  2. 多路复用：可发起多个请求，废弃了 1.1 里的管道；
  3. header 压缩：使用专用算法压缩头部，减少数据传输量；
  4. 服务端推送：允许服务器向客户端推送数据；
  5. 增强了安全性，要求通信加密；

- [浏览器强缓存与协商缓存](https://www.cnblogs.com/terrymin/p/13717855.html)

- 跨域:

  1.  定义: 跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的同源策略，会导致请求被限制的情况。同源策略是浏览器的一种安全机制，它要求网页的协议、域名和端口都相同才被认为是同源，只有同源的页面之间才能进行自由的资源共享和交互。

  2.  原因: 浏览器的同源策略是跨域问题产生的根本原因。同源策略的目的是为了防止不同源的网站之间进行恶意的脚本攻击，比如防止一个网站通过脚本读取另一个网站的敏感信息。

  3.  跨域解决方法:
      3.1 JSONP（JSON with Padding）原理：JSONP 是一种古老的跨域解决方案，它利用了 <script> 标签的 src 属性不受同源策略限制的特点。优点：兼容性好，几乎所有的浏览器都支持。

      3.2 CORS（Cross-Origin Resource Sharing）原理：CORS 是一种现代的跨域解决方案，它是 W3C 标准，允许浏览器和服务器进行跨域通信。当浏览器发起跨域请求时，会在请求头中添加一个 Origin 字段，用于标识请求的来源。服务器收到请求后，会根据自身的配置，在响应头中添加 Access-Control-Allow-Origin 等相关字段，来告诉浏览器是否允许该跨域请求。优点：支持所有的 HTTP 请求方法，是 W3C 标准，安全性高。缺点：需要服务器端进行配置，对于一些旧版本的浏览器可能不支持。

      3.3 代理服务器 原理：代理服务器是一种在服务器端进行跨域请求的解决方案。在开发环境中，可以使用开发服务器（如 Webpack Dev Server、Vite 等）的代理功能，将前端的请求转发到目标服务器。在生产环境中，可以使用 Nginx 等服务器软件作为代理服务器，将客户端的请求转发到后端服务器，从而绕过浏览器的同源策略。优点：可以在服务器端进行统一的跨域处理，不需要在前端进行额外的配置。缺点：需要额外的服务器资源，增加了系统的复杂性。

      3.4 注意: 前端通过代理方式解决跨域的原因:是利用了服务器之间不受同源策略限制的特点，通过代理服务器转发请求，从而绕过了浏览器的跨域限制。

- 基于 HTTP 定时器更新、SSE、WebScoket 之间区别(数据实时通信更新方案)

  1.  基于 HTTP 定时器更新:定时器更新页面数据是基于客户端的一种主动轮询机制。通过使用 setInterval 或 setTimeout 函数，客户端按照预设的时间间隔向服务器发送请求，获取最新的数据并更新页面 适用于数据更新频率较低、对实时性要求不高的场景。例如，一些静态网站的新闻列表更新、博客文章的点赞数统计等。
      1.1 HTTP 是半双工的，通常是客户端发起请求，服务器响应请求。

  2.  SSE（Server-Sent Events）是一种允许服务器向客户端实时推送更新数据的 Web 技术，它基于 HTTP 协议，使用简单，适合实现服务器端向客户端的单向实时数据传输，比如股票行情更新、新闻推送等场景。
      2.1 优点:
      简单易用：基于 HTTP 协议，不需要复杂的握手过程，使用起来非常简单。
      自动重连：当连接断开时，客户端会自动尝试重新连接，保证数据的连续性。
      文本格式：数据以文本格式传输，易于解析和处理。
      2.2 局限性:
      单向通信：只能由服务器向客户端发送数据，客户端不能向服务器发送数据。
      浏览器兼容性：虽然现代浏览器大多支持 SSE，但在一些旧版本的浏览器中可能存在兼容性问题。

  3.  WebScoket 是一种在单个 TCP 连接上进行全双工通信的协议，它使得客户端和服务器之间能够进行实时、双向的数据传输，适用于实时聊天、多人协作、实时数据的更新、游戏开发。
      3.1 优点:
      实时性高：全双工通信和持久连接使得数据能够实时传输，减少了延迟。
      节省资源：避免了频繁建立和断开连接的开销，降低了服务器和客户端的资源消耗。
      支持多种数据格式：可以传输文本和二进制数据，满足不同的应用需求。
      3.2 缺点:
      实现复杂度较高：需要处理连接的建立、关闭、错误等多种状态，开发和维护成本相对较高。
      安全性要求高：由于 WebSocket 连接是持久的，一旦被攻击，可能会导致数据泄露或服务中断，因此需要加强安全防护。

## Nodejs

- CommonJS 与 ES6 Module 规范的区别：

  1.  CommonJS 是同步加载，ESM 是异步加载；(由于 CommonJS 是用于服务器端的模块体系，需要加载的模块都在本地，所以采用同步加载也不会出问题，但是 ESM 用于浏览器端时，可能涉及到一些异步请求，所以需要采用异步加载。)
  2.  CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口。
  3.  ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、filename、dirname。
  4.  CommonJS 输出是值的浅拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变。
  5.  CommonJs 导入的模块路径可以是一个表达式，因为它使用的是 require()方法；而 ES6 Modules 只能是字符串。
  6.  CommonJSthis 指向当前模块，ES6 Modulesthis 指向 undefined。
