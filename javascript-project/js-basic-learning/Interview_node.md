<!--
 * @Author: TerryMin
 * @Date: 2025-01-07 11:13:52
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-03-30 17:09:28
 * @Description: file not
-->

# 后端网络

## Http

- [Http 三次握手与四次挥手](https://www.cnblogs.com/terrymin/p/14554404.html)

  1. 三次握手与四次挥手:一般是发生在用户在浏览器输入 URL 地址后,经过 DNS 域名解析返回 IP 地址,然后通过三次握手建立 Http 与 TCP 的链接。资源加载完后再进行四次挥手操作。

- [ Http2.0 与 Http1.1 区别](https://www.cnblogs.com/terrymin/articles/14010138.html)

  1. 新的二进制格式：二进制协议，不再是纯文本；将请求和响应拆分为更小的二进制帧进行传输，提高了传输效率和解析速度。
  2. 多路复用：HTTP1.1 的连接是串行的,同一时间只能发送一个请求,新的请求必须等待前一个请求完成。HTTP2 允许同时发送多个请求和响应，每个被分成多个帧，并带有唯一的流 ID，这些帧可以乱序发送，接收方根据流 ID 重新组装。多路复用提高了连接的利用率，减少了延迟和头部阻塞的问题。
  3. header 压缩：使用专用算法压缩头部，减少数据传输量；
  4. 服务端推送：允许服务器向客户端推送数据；
  5. 增强了安全性，要求通信加密；

  - HTTP 与 TCP 关系:
    1. TCP: 属于传输层协议，主要负责在不同主机的应用程序之间提供可靠的数据传输服务。它通过端口号来标识不同的应用程序，实现了端到端的数据传输。
    2. HTTP: 属于应用层协议，主要负责规定客户端和服务器之间数据交互的格式和规则，定义了如何发起请求、如何发送和接收数据以及如何处理响应等。
    3. HTTP（超文本传输协议）和 TCP（传输控制协议）:是计算机网络中不同层次的协议，它们之间存在着紧密的关系，共同为网络数据传输和应用层通信提供支持
    4. HTTP 依赖 TCP 的连接管理: TCP 负责连接的建立、维护和关闭。在 HTTP 通信中，客户端与服务器之间的每次交互通常都依赖于 TCP 连接。

- HTTP3 有哪些新特性

  1.  基于 QUIC （Quick UDP Internet Connections）协议：QUIC 协议在 UDP 之上构建，结合了 TCP 的可靠性和 UDP 的低延迟特性，解决了 TCP 连接中的队头阻塞问题。
  2.  更快的连接建立：QUIC 协议在建立连接时减少了握手次数，能够更快地建立连接，特别是在移动网络环境下，提高了连接的稳定性和速度。
  3.  更好的拥塞控制：QUIC 协议提供了更灵活和高效的拥塞控制机制，能够根据网络状况动态调整数据传输速率，优化网络性能。

  - QUIC（Quick UDP Internet Connections）协议和 UDP（User Datagram Protocol）:

    1.  QUIC（Quick UDP Internet Connections）协议和 UDP（User Datagram Protocol）均属于传输层协议
    2.  QUIC 协议：它是 UDP 协议的增强版本，在保留 UDP 低延迟特点的基础上，增加了可靠性、安全性和多路复用等功能，主要应用于 HTTP/3 协议。
    3.  UDP（User Datagram Protocol）协议：是一种轻量级的传输协议，速度快但缺乏可靠性保障，适用于实时性要求高且能接受数据丢失的场景。

- 常见 HTTP 状态码:

  1.  204 No Content: 服务器成功处理了请求,不需要返回内容。
  2.  301 Moved Permanently: 请求的资源已被永久移到新的 URL。
  3.  302 Found: 请求资源临时移到了新的 URL。
  4.  401 Unauthorized:客户端需要进行身份验证才能访问请求的资源。
  5.  403 Forbidden:客户端具有访问资源权限,但服务器拒绝了请求。
  6.  404 Not Found: 资源未找到
  7.  500 Internal Server Error：服务器内部发生了未知的错误，导致无法处理请求。
  8.  502 Bad Gateway: 服务器作为网关,上游服务求出现故障。
  9.  503 Service Unavailable: 服务器暂时不可用。

- [浏览器强缓存与协商缓存](https://www.cnblogs.com/terrymin/p/13717855.html)

  1. 定义:是浏览器缓存策略的两种形式。
  2. 强制缓存：用户访问资源优先从强制缓存中读取资源，不向服务器发送请求，通常通过 Cache-Control 或 expires 头控制，如果缓存有效期内资源没有发生变化，浏览器直接使用缓存的资源。
  3. 协商缓存：当强制缓存失效时，浏览器会发送请求到服务器，服务器根据资源的某些标识（如 Etag 或 Last-Modified）判断资源是否发生变化，如果没有变化，服务器返回 304 状态码，浏览器从缓存中读取资源，否则返回 200 和新的资源。

- [应用资源缓存 PWA](https://segmentfault.com/a/1190000041564624)

  1. PWA（Progressive Web Apps）不是特指某一项技术，而是应用多项技术来改善用户体验的 Web App，为 Web App 提供类似 Native App 的用户体验。其核心技术包括 Web App Manifest，Web Push，Service Worker 和 Cache Api 等，用户体验才是 PWA 的核心。

  2. PWA 主要特点如下：

     - 可靠 - 即使在网络不稳定甚至断网的环境下，也能瞬间加载并展现
     - 用户体验 - 快速响应，具有平滑的过渡动画及用户操作的反馈
     - 用户黏性 - 和 Native App 一样，可以被添加到桌面，能接受离线通知，具有沉浸式的用户体验

  3. 缓存
     3.1 应用缓存(Application Cache):用于存储静态资源(缓存应用程序)。
     3.2 Service Worker 本质上是充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器，独立于网页主进程。它可以拦截网络请求，实现离线支持、消息推送、后台同步等功能，为 Web 应用带来类似原生应用的用户体验。逐渐成为了 Application Cache 的替代方案。

- 跨域:

  1.  定义: 跨域是指在浏览器中打开一个域名地址的网页时去请求另一个域名的资源，由于浏览器的同源策略，会导致请求被限制的情况。同源策略是浏览器的一种安全机制，它要求网页的协议、域名和端口都相同才被认为是同源，只有同源的页面之间才能进行自由的资源共享和交互。

  2.  原因: 浏览器的同源策略是跨域问题产生的根本原因。同源策略的目的是为了防止不同源的网站之间进行恶意的脚本攻击，比如防止一个网站通过脚本读取另一个网站的敏感信息。

  3.  跨域解决方法:
      3.1 JSONP（JSON with Padding）原理：JSONP 是一种古老的跨域解决方案，它利用了 <script> 标签的 src 属性不受同源策略限制的特点。优点：兼容性好，几乎所有的浏览器都支持。

      3.2 CORS（Cross-Origin Resource Sharing）原理：CORS 是一种现代的跨域解决方案，它是 W3C 标准，允许浏览器和服务器进行跨域通信。当浏览器发起跨域请求时，会在请求头中添加一个 Origin 字段，用于标识请求的来源。服务器收到请求后，会根据自身的配置，在响应头中添加 Access-Control-Allow-Origin 等相关字段，来告诉浏览器是否允许该跨域请求。优点：支持所有的 HTTP 请求方法，是 W3C 标准，安全性高。缺点：需要服务器端进行配置，对于一些旧版本的浏览器可能不支持。

      3.3 代理服务器 原理：代理服务器是一种在服务器端进行跨域请求的解决方案。在开发环境中，可以使用开发服务器（如 Webpack Dev Server、Vite 等）的代理功能，将前端的请求转发到目标服务器。在生产环境中，可以使用 Nginx 等服务器软件作为代理服务器，将客户端的请求转发到后端服务器，从而绕过浏览器的同源策略。优点：可以在服务器端进行统一的跨域处理，不需要在前端进行额外的配置。缺点：需要额外的服务器资源，增加了系统的复杂性。

      3.4 注意: 前端通过代理方式解决跨域的原因:是利用了服务器之间不受同源策略限制的特点，通过代理服务器转发请求，从而绕过了浏览器的跨域限制。

- 前端页面数据实时更新方案 轮询、SSE、WebScoket 之间区别

  1.  轮询
      1.1 传统轮询:客户端按照固定的时间间隔（如每隔 5 秒）向服务器发送请求，询问是否有新的数据
      1.2 长轮询:客户端向服务器发送请求，服务器接收到请求后，如果没有新的数据，会保持这个请求连接打开，不立即返回响应。服务器持续监听数据的变化，一旦有新数据产生或者达到预设的超时时间，就会返回响应给客户端。客户端处理完响应后，会立即再次发送新的请求，继续保持与服务器的通信。
      1.3 轮询缺点:
      1.3.1 实时性差:轮询时间设置过长,会导致数据获取延迟较大。
      1.3.2 性能开销大:不论是否有数据,频繁发送请求,消耗大量资源带宽,增加服务器的压力。
      1.3.3 资源浪费:频繁的请求需要消耗更多的 CPU 和内存资源来处理这些请求和响应。
      1.4 应用场景:

          - 传统轮询:适用于对实时性要求不高，数据更新频率较低的场景，如一些静态页面的定期数据刷新，或者对服务器资源和网络带宽要求不严格的应用。
          - 长轮询:适用于对实时性有一定要求，但又不适合使用 WebSocket 等全双工通信协议的场景，如网页端的聊天应用、消息提醒、股票行情更新等。

  2.  SSE（Server-Sent Events）是一种允许服务器向客户端实时推送更新数据的 Web 技术，它基于 HTTP 协议，使用简单，适合实现服务器端向客户端的单向实时数据传输，比如股票行情更新、新闻推送等场景。
      2.1 优点:
      简单易用：基于 HTTP 协议，不需要复杂的握手过程，使用起来非常简单。
      自动重连：当连接断开时，客户端会自动尝试重新连接，保证数据的连续性。
      文本格式：数据以文本格式传输，易于解析和处理。
      优势体现：相较于轮询方式，SSE 能减少不必要的网络请求，降低服务器和客户端的资源消耗，同时保证数据的实时性，用户无需手动刷新页面就能看到最新内容。

      2.2 局限性:
      单向通信：只能由服务器向客户端发送数据，客户端不能向服务器发送数据。
      浏览器兼容性：虽然现代浏览器大多支持 SSE，但在一些旧版本的浏览器中可能存在兼容性问题。

      2.3 保持连接不被中断:
      2.3.1 重试机制:错误处理与重连机制,设置最大重连次数。
      2.3.2 心跳机制:客户端定期向服务器发送心跳请求，以保持与服务器的连接。服务器接收到心跳请求后，返回一个响应，表明连接仍然有效。

  3.  WebScoket 是一种在单个 TCP 连接上进行全双工通信的协议，它使得客户端和服务器之间能够进行实时、双向的数据传输，适用于实时聊天、多人协作、实时数据的更新、游戏开发。
      3.1 优点:
      实时性高：全双工通信和持久连接使得数据能够实时传输，减少了延迟。
      节省资源：避免了频繁建立和断开连接的开销，降低了服务器和客户端的资源消耗。
      支持多种数据格式：可以传输文本和二进制数据，满足不同的应用需求。
      3.2 缺点:
      实现复杂度较高：需要处理连接的建立、关闭、错误等多种状态，开发和维护成本相对较高。
      安全性要求高：由于 WebSocket 连接是持久的，一旦被攻击，可能会导致数据泄露或服务中断，因此需要加强安全防护。
      3.3 webScoket 中断后恢复重连处理:
      3.3.1 记录消息序列号: webScoket 传输数据是实时的。断线期间的数据补发：后端应记录断线期间的消息，并在前端重连后补发这些消息。前端可以记录最后接收到的消息时间戳或序列号，重连后发送给后端，后端根据该信息补发后续消息。
      3.3.2 缓存数据: 前端可以缓存已接收的消息，避免页面刷新或重连后数据丢失。

- CDN 作用和原理

  1. 定义：CDN 即内容分发网络，是一种通过在网络各处放置节点服务器，从而更高效地向用户提供内容的分布式网络系统。
  2. CDN 的作用
     2.1 加速内容传输
     2.2 减轻源服务器压力
     2.3 提高内容可用性和可靠性
     2.4 提升用户体验
  3. CDN 的原理
     3.1 内容缓存：源服务器把内容推送到 CDN 网络的各个节点服务器，节点服务器根据缓存策略，将经常访问的内容缓存起来。如网站的 logo、导航栏等静态资源，会被缓存到 CDN 节点。
     3.2 用户请求路由：用户请求内容时，浏览器先向本地 DNS 服务器查询域名对应的 IP 地址。CDN 的智能 DNS 解析系统会根据用户的地理位置、网络状况、服务器负载等因素，返回距离用户最近、负载较轻的 CDN 节点服务器的 IP 地址。这样用户的请求就被路由到合适的节点服务器上。
     3.3 内容交付：用户与选定的 CDN 节点服务器建立连接后，服务器将缓存的内容发送给用户。如果节点服务器上没有用户请求的内容，就会向源服务器请求获取，并将内容缓存到本地后再发送给用户，同时更新缓存策略，以便后续相同请求能直接从本地缓存获取。

## 设计模式

- 设计模式基本问题
  1. 熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等
  2. 发布订阅模式和观察者模式的异同以及实际应用
  3. 可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用
