<!--
 * @Author: TerryMin
 * @Date: 2025-01-07 11:13:52
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-03-21 07:38:16
 * @Description: file not
-->

# [Vue](https://cn.vuejs.org/)

## Vue

- [手写 Vue-router 核心原理](https://cloud.tencent.com/developer/article/1880448)

- ref 与 reactive 区别？

  1. 定义:
     1.1 ref 用于创建一个包含单个响应式值的引用对象。它可以接收任何类型的值，包括基本数据类型（如 number、string、boolean）和引用数据类型（如 object、array）。
     1.2 使用方式：通过 ref 函数创建一个响应式引用，访问其值时需要使用 .value 属性。
     1.3 定义: reactive 用于创建一个响应式的对象或数组，它只能接收对象类型（包括普通对象、数组、Map、Set 等）。
     1.4 使用方式: 直接使用 reactive 函数将一个对象转换为响应式对象，访问和修改其属性时无需使用 .value。

  2. 实现原理:
     2.1 ref 内部使用了 Object.defineProperty() 或 Proxy（取决于运行环境）来实现响应式。。它将传入的值包装在一个对象中，并通过 getter 和 setter 来拦截对 .value 属性的访问和修改，从而实现响应式更新。
     2.2 reactive 基于 Proxy 实现响应式。它创建一个代理对象，拦截对原对象属性的访问和修改操作，当属性值发生变化时，会触发相应的更新机制，通知依赖该数据的组件进行重新渲染。

- [Vue 生命周期](https://cn.vuejs.org/guide/essentials/lifecycle)
- Vue Hooks 与 工具方法的区别

  1.  概念:
      1.1 Vue Hooks：它是基于 Vue 3 组合式 API 衍生出来的一种代码组织方式，本质上是一个函数，通常会使用 Vue 的响应式系统（如 ref、reactive）和生命周期钩子（如 onMounted、onUnmounted）。其主要目的是将有状态的逻辑进行封装和复用，能在不同组件间共享逻辑与状态。
      1.2 工具方法：是普通的 JavaScript 函数，不依赖于 Vue 特定的 API。它主要用于封装一些通用的、无状态的功能，像数据处理、格式转换、数学计算等，可在项目的任意地方使用，不局限于 Vue 组件。

  2.  功能用途:
      2.1 Vue Hooks：侧重于处理有状态的逻辑和组件生命周期相关的操作。例如，处理表单验证逻辑、实现数据的懒加载、监听窗口大小变化等，这些逻辑通常与组件的状态和生命周期紧密相关。
      2.2 工具方法：主要用于执行一些独立的、无状态的任务。比如，格式化日期、生成随机数、加密解密数据等

  3.  依赖关系
      3.1 Vue Hooks：依赖于 Vue 的响应式系统和生命周期钩子，因此只能在 Vue 项目中使用，并且通常需要使用 Vue 3 的组合式 API。
      3.2 工具方法：不依赖于 Vue 框架，具有更高的通用性，可以在任何 JavaScript 项目中使用，无论是 Vue、React 还是其他框架，或者是纯 JavaScript 项目。

- Vue2 中 watch 与 computed 区别

  1.  相同点：他们两者都是观察页面数据变化的。
  2.  不同点：computed 只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据,主要用于快速计算视图(View)中显示的属性。 watch 每次都需要执行函数。watch 更适用于数据变化时的异步操作。 3. watch 与 computed 最大的区别： 当需要在数据变化时执行异步或开销较大的操作时，watch 是最有用的。

- watch 与 watchEffect 区别

  1.  watch 和 watchEffect 都用于响应式地监听数据的变化并执行相应的操作，但它们在使用方式、触发时机、依赖收集等方面存在一些区别。
  2.  watch 显式依赖：watch 需要明确指定要监听的数据源，只有当指定的数据源发生变化时，回调函数才会被触发。惰性执行，可以传递 immediate: true 选项来让 watch 在组件初始化时立即执行一次回调。
  3.  watchEffect 自动依赖收集：watchEffect 会自动收集回调函数中使用的所有响应式数据作为依赖，只要这些依赖中的任何一个发生变化，回调函数就会重新执行

  ```js
  <script setup>
   import { ref, watchEffect } from 'vue';

   const message = ref('');

   watchEffect(() => {
     console.log(`当前消息是: ${message.value}`);
   });
   watch(message, (newValue, oldValue) => {
     console.log(`消息从 ${oldValue} 变为 ${newValue}`);
   }, {
     immediate: true
   });
   </script>
  ```

- Vue 中 <KeepAlive>组件缓存原理?

  1. <KeepAlive> 通过维护一个缓存对象,获取组件的名称作为缓存标识,在组件切换时对组件实例进行缓存和复用，同时利用特殊的生命周期钩子来管理组件的激活和失活状态，从而实现了组件的高效缓存和性能优化。
  2. 组件激活与失活:
     2.1 deactivated：当组件从活跃状态变为不活跃状态（即被切换走）时，会触发 deactivated 钩子。此时组件实例不会被销毁，而是被缓存起来。
     2.2 activated：当组件从缓存中重新被激活（即再次被切换回来）时，会触发 activated 钩子。这样可以在组件重新显示时执行一些特定的操作。
  3. 更新缓存组件方法:
     3.1 keep-alive 的 include 和 exclude 属性可以用来指定哪些组件需要被缓存，哪些不需要。通过动态修改这两个属性，可以控制组件是否被缓存，从而达到更新组件的目的。
     3.2 为被缓存的组件动态设置不同的 key 值，当 key 发生变化时，keep-alive 会认为是一个新的组件实例，从而重新创建组件。
     3.3 手动清除缓存: 可以通过访问 keep-alive 实例的 cache 和 keys 属性来实现。

- $nextTick 实现原理

  1. 异步更新：Vue 通过异步更新队列来批量更新 DOM，提高性能。
  2. $nextTick：用于在 DOM 更新完成后执行回调函数，确保能访问到最新的 DOM 状态。
  3. 实现原理：$nextTick 的实现主要依赖于 JavaScript 的事件循环机制，根据不同的环境选择合适的异步方法（如 Promise.then、MutationObserver、setImmediate、setTimeout 等）来执行回调函数。

- Vue 组件通信有几种方式

  1.  子组件向父组件传递数据:
      1.1 自定义事件（defineEmits）
      1.2 v-model 指令(本质上也是基于自定义事件实现)
      1.3 provide 和 inject 主要用于跨层级组件通信,这种方式会让组件间的耦合度增加。
      1.4 事件总线（Event Bus）(Vue 3 官方不再推荐使用事件总线)
      1.5 状态管理

- vue 事件总线 和状态管理分别在什么场景下使用

  1. 事件总线适用于简单的组件通信和一次性的事件传递，而状态管理适用于多个组件共享状态和复杂的状态逻辑管理。在实际项目中，需要根据项目的规模和需求来选择合适的通信方式。
  2. 备注：一次性的事件通信：如果组件间的通信是一次性的，比如某个组件在特定条件下触发一个事件，通知其他组件执行相应操作，使用事件总线会很合适。例如，在用户点击某个按钮后，通知另一个组件进行页面滚动。

- Vue 响应式原理(源码)

  1.  compiler:主要负责把 Vue 组件的模板字符串转化为 JavaScript 渲染函数,这些渲染函数在运行时会生成虚拟 DOM 树，最终被渲染为真实的 DOM 节点。
  2.  reactivity:添加数据响应式,进行依赖收集
      2.1 Object.defineProperty: Vue 2 在创建 Vue 实例时，会遍历 data 选项中的所有属性，使用 Object.defineProperty() 将这些属性转换为 getter/setter 进行数据劫持并在 Watcher 中进行依赖收集,当属性值发生变化会发布更新。
      2.2 Object.defineProperty 缺点: 不能监听数组(重写会改变数组本身的方法)、对嵌套对象属性需要递归添加 getter 与 setter,比较浪费性能、对 ES6 新的数据结构 Map 和 Set 不支持响应式。
      2.3 Proxy(Reflect 先进语法):get 与 set 响应式数据拦截加工、track 响应式数据依赖追踪收集添加到 Map 数据结构里面、trigger 触发更新
  3.  runtime:是 Vue 3 框架中连接虚拟 DOM 和真实 DOM 的桥梁，它通过实现渲染器、封装 DOM 操作、处理特定指令和组件等功能，使得 Vue 应用能够高效地在浏览器中运行，并实现数据驱动的视图更新。

- Vue 编译过程
  Vue 的编译过程主要包括模板解析、优化和代码生成三个阶段:

  1. 解析: 将模板字符串通过词法分析和语法分析解析成（AST，Abstract Syntax Tree），便于后续处理；
  2. 优化: 对 AST 进行优化，通过深度优先遍历 标记出静态节点和静态根节点，以提高渲染性能；
  3. 生成: 将优化后的 AST 转换为渲染函数的代码字符串。渲染函数会生成虚拟 DOM，最终映射到真实 DOM 上

- Vue2 和 Vue3 有哪些区别？

      1. 语法与组合式 API:Vue2 使用选项式 API;Vue3 使用组合式 API,使用函数来组织逻辑,Vue 3 也兼容选项式 API，方便老项目的迁移。
      2. 响应式系统:
      vue2 的响应式原理用 Object.defineProperty 的 get 和 set 进行数据劫持;
      vue3 中响应式原理使用 Proxy 进行代理,Proxy 可以拦截对象中任意的属性变化，当然包括读写，添加，删除等
      3. 虚拟DOM性能优化:对虚拟 DOM 进行了优化，采用了静态提升、PatchFlag 等技术，减少了不必要的 diff 计算，提高了渲染性能，尤其是在处理大型组件树时性能提升明显。
      4. 更好的TypeScript支持: Vue3 增强的 TypeScript 支持，使大规模应用开发更轻松,新增了一些状态管理库pinia。
      5. 生命周期钩子部分做了调整:Vue3大部分生命周期钩子仍然保留，但名称有所变化。例如，beforeDestroy 改为 beforeUnmount，destroyed 改为 unmounted。同时，在组合式 API 中，可以使用新的方式来使用生命周期钩子，如 onBeforeMount、onMounted 等

- 说说函数式编程理解

  1. 函数式编程（Functional Programming，FP）是一种编程范式，它将计算视为函数的求值，避免使用共享状态和可变数据，强调函数的纯粹性和不可变性。
     1.1 纯函数:纯函数是函数式编程的核心概念之一，它具有两个重要特性。一是相同的输入始终会返回相同的输出，不受任何外部状态的影响；二是不会产生任何副作用，如修改全局变量、改变外部数据结构、进行 I/O 操作等。
     1.2 不可变数据:不可变数据指的是一旦创建就不能被修改的数据。在函数式编程中，通常通过创建新的数据结构来代替修改现有数据，这样可以避免因数据的意外修改而导致的复杂问题，提高代码的可维护性和可预测性。
     1.3 高阶函数:高阶函数是指可以接受一个或多个函数作为参数，并且 / 或者返回一个函数的函数。高阶函数使得函数可以像普通数据一样被传递和使用，增加了代码的灵活性和复用性。
     1.4 函数组合(柯里化):函数组合是将多个函数组合成一个新函数的过程。通过函数组合，可以将复杂的操作拆分成多个简单的函数，然后将这些函数组合起来完成复杂的任务，使代码更加模块化和易于维护。

  2. 柯里化（Currying）是一种将多参数函数转换为一系列单参数函数的技术。通过柯里化，我们可以逐步传递参数，直到所有参数都被提供，然后执行原函数并得到最终结果。

  3. Vue3 中 Composition API: 通过函数组合实现 UI 与状态解耦
  4. OOP（面向对象编程）:封装、继承、多态
  5. 函数式编程优缺点:
     - 优点:复用性强、更好的状态管理、组合更灵活、减少代码量，提高维护性。
     - 缺点: 资源占用大：在 JS 中为了实现对象状态的不可变，往往会创建新的对象、递归消耗性能。

- MVVM 你是怎么理解

  1.  MVVM（Model-View-ViewModel）是一种前端开发的设计模式，它是在 MVC（Model-View-Controller）和 MVP（Model-View-Presenter）模式的基础上发展而来，主要用于实现视图（View）和数据模型（Model）的分离，提高代码的可维护性和可测试性。
  2.  MVVM 模式通过引入 ViewModel 实现了视图和数据模型的分离，利用数据绑定和双向数据绑定机制实现了两者之间的自动同步，在提高代码可维护性和可测试性方面具有显著优势，是现代前端开发中常用的设计模式之一。
  3.  [MVVM 与 MVC 区别](https://blog.csdn.net/qq_51066068/article/details/125441774)

- 注意事项

  1.  在回答性能优化相关问题时，建议结合具体项目场景，**突出你的技术深度和解决问题的能力**。通过清晰的逻辑和实际案例，展示你在性能优化方面的经验和成果。

- 你在项目中遇到哪些问题是如何解决的？(问题描述 - 分析原因(多方案对比) - 解决办法 - 经验总结)

  1.  项目工程化优化:
      1.1 咪咕影院 H5 项目版本升级: 该项目由于常年业务迭代,导致页面模块不断累积,开发时编译和打包时间接近 1 分钟多。首先通过 Speed Measure Plugin 和编译耗时相关分析工具进行分析具体原因; 制定优化方案:项目版本升级 webpack5、开启多线程打包、开启 webpack 缓存。
      1.2 Webpack 5 相比 Webpack 4 在打包启动速度上有显著提升: 引入了持久化缓存机制、模块联邦（Module Federation）、优化了模块解析算法和并行处理能力增强、更好的 Tree Shaking 支持
      1.3 经验总结:规范代码开发,通过程序配置层面去控制编码规范

  2.  参与项目微内核系统架构设计开发:
      2.1 视频播放器是一个独立的模块作为内核，广告插件、弹幕插件、会员插件等等

  3.  利用模块联邦提高开发效率:
      3.1 利用模块联邦,页面复用,提高开发效率

- 说说你对低代码平台的理解

  1.  定义:低代码平台（Low-Code Platform）是一种可视化的软件开发平台，它通过提供图形化界面和少量代码编写的方式，让开发者能够快速创建应用程序
  2.  优势:
      2.1 提高开发效率
      2.2 降低开发成本
      2.3 促进业务与技术融合
  3.  挑战与局限:
      3.1 定制化能力有限：虽然低代码平台提供了一定的自定义功能，但在处理复杂的业务逻辑和特殊需求时，可能会受到平台的限制
      3.2 性能和安全性问题

- 前端性能优化方式:

  1. 网络层面优化:
     1.1 减少 http 请求: 使用工具对代码进行压缩。将多个 CSS(mini-css-extract-plugin) 文件合并为一个，多个 JavaScript 文件合并为一个,使用 base64 表示简单的图片,减少 HTTP 请求次数。

     1.2 减少资源体积:js 压缩(terser-webpack-plugin)、css 压缩(css-minimizer-webpack-plugin)、图片压缩、gzip 压缩

     1.3 缓存:

     - DNS(（Domain Name System) 缓存:由于浏览器会在 DNS 解析步骤中消耗一定的时间，所以，对于一些高访问量网站来说，做好 DNS 的缓存工作，就会一定程度上提升网站效率
     - CDN(Content Delivery Network) 缓存:CDN 作为静态资源文件的分发网络，本身就已经提升了，网站静态资源的获取速度，加快网站的加载速度，同时也给静态资源做好缓存工作，有效的利用已缓存的静态资源，加快获取速度
     - HTTP 缓存:也是给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复的下载，从而提升整体网页的加载速度[缓存](https://www.cnblogs.com/terrymin/p/13717855.html)

  2. 工程化层面: 资源(图片、脚本、CSS 样式)优化
     2.1 图片懒加载: 可以使用 IntersectionObserver API 实现图片懒加载
     2.2 JS 模块按需加载:使用动态导入（Dynamic Import）来按需加载 JavaScript 模块，避免一次性加载所有的 JavaScript 代码。

     2.3 预加载与预渲染: 对于重要的资源（如关键的脚本和样式表），使用预加载（<link rel="preload">）提前加载到浏览器缓存中。对于一些可能会被用户访问的页面，使用预渲染（<link rel="prerender">）提前在后台渲染，当用户访问时可以立即显示
     2.4 预渲染(渲染方式分为三种:客户端渲染,服务端渲染,预渲染)

     - 服务端渲染(Server-Side Rendering，SSR):
       在服务端渲染模式下，服务器在接收到客户端请求后，会将页面的初始 HTML 内容生成并发送给客户端。客户端接收到 HTML 后，进行解析和渲染，最终呈现给用户。在这种模式下，页面的大部分内容在服务器端已经渲染完成，因此页面加载速度相对较快，并且对搜索引擎友好。但是，交互式的内容和功能需要等待客户端的 JavaScript 代码执行完成后才能实现。对应的库(Next.js:基于 React 的 SSR 框架,Nuxt.js:基于 Vue 的 SSR 框架)

     - 客户端渲染（Client-Side Rendering，CSR）:
       在客户端渲染模式下，服务器返回一个基本的 HTML 页面结构和一些必要的 JavaScript 和 CSS 文件。然后，客户端的浏览器通过执行 JavaScript 代码来请求数据，并根据数据动态生成页面内容。这种模式下，页面的渲染过程主要由客户端的浏览器完成，可以实现更丰富的交互和动态内容。但是，初始加载时需要下载和执行大量的 JavaScript 代码，页面加载速度相对较慢，对搜索引擎的可访问性较差。对应的库(React,Vue)

     - 预渲染:
       就是将浏览器解析 javascript 动态渲染页面的这部分工作，在打包阶段就完成了，（只构建了静态数据）换个说法在构建过程中，webpack 通过使用 prerender-spa-plugin 插件生成静态结构的 html

  3. 项目开发层面:DOM 层面优化
     3.1 重绘和回流:

     - 重绘:是指当元素的外观（如颜色、背景色、边框颜色等不影响布局的样式）发生改变时，浏览器重新绘制该元素的过程。它不会引起页面布局的重新计算。
     - 回流:即重排，是指当 DOM 的结构或者元素的几何属性（如宽度、高度、位置、浮动等）发生变化时，浏览器需要重新计算元素的布局，并重新绘制受影响的部分。回流的性能开销比重绘要大得多，因为它涉及到重新布局整个页面或者部分页面。

  4. 复杂的脚本执行性能问题:
     4.1 减少 DOM 操作:使用文档片段（DocumentFragment）来批量处理 DOM 节点，最后再将文档片段插入到 DOM 树中。
     4.2 防抖与节流
     4.3 使用 Web Workers:对于一些耗时的计算任务，可以将其放到 Web Workers 中执行，避免阻塞主线程。Web Workers 可以在后台线程中独立运行，不会影响页面的渲染和交互。

- 微内核系统架构

  1. 微内核架构（也称为插件化架构）:是一种将系统的核心功能和扩展功能分离的架构模式。核心系统提供基本的服务和功能，而扩展功能则以插件的形式存在，这些插件可以根据需要动态地加载和卸载，从而实现系统的功能扩展
  2. [微内核架构在前端实现及其应用](https://juejin.cn/post/7163078031601303583)
  3. 多个插件运行方式:
     3.1 管道式:插件直接顺序执行
     3.2 洋葱式:插件也是顺序执行,但是会经过两次（如： koa 中间件、babel 遍历过程中访问器 vistor 的进出过程也是如此）。
     3.3 集散式:插件独立作用,和顺序无关,一般不修改内核,而是扩展功能

- 微前端了解么？
  [微前端架构](https://blog.csdn.net/mmc123125/article/details/143559240#)

  1.  定义: 微前端是一种将前端应用拆分成多个小型、自治的前端应用，并将这些小型应用组合成一个大型前端应用的架构模式。它借鉴了后端微服务架构的思想，强调将前端应用按照业务功能进行拆分，每个微前端应用可以独立开发、测试、部署和维护。
  2.  微前端解决的问题:解决不同产品之间集成困难、可以达到与技术栈无关、独立开发、独立部署。可扩展性和灵活性高

- 微内核与微前端区别:

  1. 微前端
     - 优点：提高开发效率、技术栈灵活、易于维护和扩展。
     - 缺点：通信复杂性较高、性能开销可能较大、部署和运维难度相对较大。
     - 适用场景：适用于大型前端应用的开发，尤其是由多个团队协同开发、业务功能复杂且不断变化的项目。例如电商平台的前端应用，不同的业务模块（如商品展示、购物车、订单管理等）可以拆分成独立的微前端应用，由不同的团队负责开发和维护。
  2. 微内核架构
     - 优点：高度可扩展性和灵活性、核心系统稳定、便于功能扩展和定制。
     - 缺点：插件管理和兼容性问题可能较为复杂、对核心系统的设计要求较高。
     - 适用场景：常用于需要高度可扩展性和灵活性的系统，如编辑器、浏览器等。这些系统的核心功能相对稳定，但需要支持各种插件来扩展功能，用户可以根据自己的需求选择安装不同的插件。

- 模块联邦(Module Federation)
  [ Module Federation 2.0 构建下一代微前端架构](https://segmentfault.com/a/1190000045448357)

- 组件库设计
