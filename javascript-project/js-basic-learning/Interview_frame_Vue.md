<!--
 * @Author: TerryMin
 * @Date: 2025-01-07 11:13:52
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-02-21 18:46:24
 * @Description: file not
-->

# [Vue](https://cn.vuejs.org/)

## Vue

- [手写 Vue-router 核心原理](https://cloud.tencent.com/developer/article/1880448)

- Vue2 和 Vue3 有哪些区别？

      1 语法与组合式 API:Vue2 使用选项式 API;Vue3 使用组合式 API,使用函数来组织逻辑
      2 响应式系统:
      vue2 的响应式原理用 Object.defineProperty 的 get 和 set 进行数据劫持;
      vue3 中响应式原理使用 Proxy 进行代理,Proxy 可以拦截对象中任意的属性变化，当然包括读写，添加，删除等
      3 语言支持变更: Vue3 增强的 TypeScript 支持，使大规模应用开发更轻松
      4 构建工具:Vue2 主要使用的是 webpack 打包工具,Vue3 使用的是 Vite

- ref 与 reactive 区别？

      1 ref 定义的是基本数据类型
      2 ref 通过 Object.defineProperty()的 get 和 set 实现数据劫持
      3 ref 操作数据.value，读取时不需要.value
      4 reactive 定义对象或数组数据类型
      5 reactive 通过 Proxy 实现数据劫持
      6 reactive 操作和读取数据不需要.value

- Vue 数据更新机制？
  Vue.js 的异步更新机制主要基于以下几个步骤：

      1.  数据变化检测：Vue.js 通过 Object.defineProperty 或 Proxy 来监听数据变化，当数据发生变化时，会触发 setter 方法。
      2.  依赖收集：当 setter 方法被触发时，将当前依赖的数据属性和对应的 watcher 对象存储起来。
      3.  异步队列：Vue.js 将数据变化的更新操作放入异步队列中，等待事件循环周期结束再统一执行。
      4.  DOM 更新：在事件循环周期结束之后，Vue.js 会执行异步队列中的更新操作，从而更新 DOM。

  优势与劣势:
  优势:

      1.  提高性能：通过减少 DOM 操作的次数，提高页面性能。
      2.  避免闪烁：在数据更新时，不会立即更新 DOM，从而避免页面闪烁。
      3.  批量更新：在事件循环周期结束之后，Vue.js 会执行异步队列中的所有更新操作，从而提高更新效率。

  劣势:

      1.  复杂度增加：异步更新机制使得 Vue.js 的内部实现更加复杂。
      2.  难以调试：在开发过程中，由于异步更新的存在，可能导致一些难以调试的问题。

5. [Vue 生命周期](https://cn.vuejs.org/guide/essentials/lifecycle)

- 前端性能优化方式:

      1. 网络层面优化:
         1.1 减少 http 请求: 使用工具对代码进行压缩。将多个 CSS(mini-css-extract-plugin) 文件合并为一个，多个 JavaScript 文件合并为一个,使用 base64 表示简单的图片,减少 HTTP 请求次数。

         1.2 减少资源体积:js 压缩(terser-webpack-plugin)、css 压缩(css-minimizer-webpack-plugin)、图片压缩、gzip 压缩

         1.3 缓存:

         - DNS(（Domain Name System) 缓存:由于浏览器会在 DNS 解析步骤中消耗一定的时间，所以，对于一些高访问量网站来说，做好 DNS 的缓存工作，就会一定程度上提升网站效率
         - CDN(Content Delivery Network) 缓存:CDN 作为静态资源文件的分发网络，本身就已经提升了，网站静态资源的获取速度，加快网站的加载速度，同时也给静态资源做好缓存工作，有效的利用已缓存的静态资源，加快获取速度
         - HTTP 缓存:也是给资源设定缓存时间，防止在有效的缓存时间内对资源进行重复的下载，从而提升整体网页的加载速度[缓存](https://www.cnblogs.com/terrymin/p/13717855.html)

      2. 资源(图片、脚本、CSS 样式)优化:
         2.1 图片懒加载: 可以使用 IntersectionObserver API 实现图片懒加载
         2.2 JS 模块按需加载:使用动态导入（Dynamic Import）来按需加载 JavaScript 模块，避免一次性加载所有的 JavaScript 代码。

         2.3 预加载与预渲染: 对于重要的资源（如关键的脚本和样式表），使用预加载（<link rel="preload">）提前加载到浏览器缓存中。对于一些可能会被用户访问的页面，使用预渲染（<link rel="prerender">）提前在后台渲染，当用户访问时可以立即显示
         2.4 预渲染(渲染方式分为三种:客户端渲染,服务端渲染,预渲染)

         - 服务端渲染(Server-Side Rendering，SSR):
         在服务端渲染模式下，服务器在接收到客户端请求后，会将页面的初始 HTML 内容生成并发送给客户端。客户端接收到 HTML 后，进行解析和渲染，最终呈现给用户。在这种模式下，页面的大部分内容在服务器端已经渲染完成，因此页面加载速度相对较快，并且对搜索引擎友好。但是，交互式的内容和功能需要等待客户端的 JavaScript 代码执行完成后才能实现。对应的库(Next.js:基于 React 的 SSR 框架,Nuxt.js:基于 Vue 的 SSR 框架)

         - 客户端渲染（Client-Side Rendering，CSR）:
         在客户端渲染模式下，服务器返回一个基本的 HTML 页面结构和一些必要的 JavaScript 和 CSS 文件。然后，客户端的浏览器通过执行 JavaScript 代码来请求数据，并根据数据动态生成页面内容。这种模式下，页面的渲染过程主要由客户端的浏览器完成，可以实现更丰富的交互和动态内容。但是，初始加载时需要下载和执行大量的 JavaScript 代码，页面加载速度相对较慢，对搜索引擎的可访问性较差。对应的库(React,Vue)

         - 预渲染:
         就是将浏览器解析 javascript 动态渲染页面的这部分工作，在打包阶段就完成了，（只构建了静态数据）换个说法在构建过程中，webpack 通过使用 prerender-spa-plugin 插件生成静态结构的 html

      3. DOM 层面优化:
         3.1 重绘和回流:
         重绘:是指当元素的外观（如颜色、背景色、边框颜色等不影响布局的样式）发生改变时，浏览器重新绘制该元素的过程。它不会引起页面布局的重新计算。

         回流:即重排，是指当 DOM 的结构或者元素的几何属性（如宽度、高度、位置、浮动等）发生变化时，浏览器需要重新计算元素的布局，并重新绘制受影响的部分。回流的性能开销比重绘要大得多，因为它涉及到重新布局整个页面或者部分页面。

      4. 复杂的脚本执行性能问题:
         4.1 减少 DOM 操作:使用文档片段（DocumentFragment）来批量处理 DOM 节点，最后再将文档片段插入到 DOM 树中。
         4.2 防抖与节流
         4.3 使用 Web Workers:对于一些耗时的计算任务，可以将其放到 Web Workers 中执行，避免阻塞主线程。Web Workers 可以在后台线程中独立运行，不会影响页面的渲染和交互。

- 你在项目中遇到哪些问题是如何解决的？(问题描述 - 分析原因 - 解决办法 - 经验总结)

      1. 项目打包启动优化方面:
         1.1 咪咕影院 H5 项目版本升级: 该项目由于常年业务迭代,导致页面模块不断累积,开发时编译和打包时间接近1分钟多。首先通过 Speed Measure Plugin和编译耗时相关分析工具进行分析具体原因; 制定优化方案:项目版本升级webpack5、开启多线程打包、开启webpack缓存。
         1.2 Webpack 5 相比 Webpack 4 在打包启动速度上有显著提升: 引入了持久化缓存机制、模块联邦（Module Federation）、优化了模块解析算法和并行处理能力增强、更好的 Tree Shaking 支持
         1.3 经验总结:规范代码开发,通过程序配置层面去控制编码规范
      2. 项目页面优化方面:
         咪咕汇页面搭建后tab切换页面很卡顿; 通过浏览器Performance面板性能分析,主要还是资源太多;
         解决方式: 公共资源抽离,组件采用动态异步方式加载,tab切换改成路由切换方式进行优化加载对应资源
      

### 性能优化专题

- 微前端了解么？
  [微前端架构](https://blog.csdn.net/mmc123125/article/details/143559240#)
  5.1 微前端解决的问题:解决不同产品之间集成困难、可以达到与技术栈无关、独立开发、独立部署
  5.2 微前端与传统项目区别:

  - 架构设计: 传统项目整个前端应用是一个单一、庞大的代码库，所有的功能模块和业务逻辑都紧密耦合在一起。微前端架构将前端应用拆分成多个小型、自治的微前端应用。每个微前端应用专注于特定的业务功能

  - 技术栈选择:传统单体式前端项目开始时就需要确定统一的技术栈，整个项目都基于该技术栈进行开发。微前端架构中各个微前端应用可以根据自身的需求选择不同的技术栈

  - 可扩展性和灵活性:传统单体式前端项目由于各个功能模块紧密耦合，当需要添加新的功能或对现有功能进行扩展时，可能需要对整个项目的代码进行大规模修改，扩展性较差。微前端架构具有较高的可扩展性，当需要添加新的功能时，可以开发一个新的微前端应用并集成到现有系统中，无需对其他微应用进行修改。

- 模块联邦(Module Federation)
  [ Module Federation 2.0 构建下一代微前端架构](https://segmentfault.com/a/1190000045448357)
