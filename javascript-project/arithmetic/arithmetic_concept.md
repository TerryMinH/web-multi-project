<!--
 * @Author: TerryMin
 * @Date: 2022-06-16 09:35:23
 * @LastEditors: TerryMin
 * @LastEditTime: 2025-04-19 17:13:54
 * @Description: file not
-->

# 数据结构与算法

[个人算法博客总结](https://i.cnblogs.com/tags/posts?tagId=4241828)

## 算法复杂度分析

- 时间复杂度(渐进时间复杂度（asymptotic time complexity）):表示算法的执行时间与数据规模之间的增长关系。

  1.  T(n)=O(f(n))
  2.  时间复杂度分析
      2.1 只关注循环执行次数最多的一段代码
      2.2 加法法则：总复杂度等于量级最大的那段代码的复杂度
      2.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

  3.  复杂度量级
      3.1![复杂度量级](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg?wh=1142*572)
      3.2 我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

- 空间复杂度:全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

  1.  我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

## 数据结构:

- 数组（Array）:是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

  1.  ![线性表结构](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg?wh=1142*833)

- 队列（Queue）:是一种特殊的线性表；特殊之处在于它只允许在表的前端（front）即队头 进行删除操作，而在表的后端（rear）即队尾 进行插入操作，和栈一样，队列是一种操作受限制的线性表。即先进先出（FIFO）。（银行窗口排队例子）

- 栈（Stack）:栈是一种遵从先进后出 (LIFO) 原则的有序集合；在栈顶进行 元素的添加或者删除，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。(堆叠的盘子例子)。

- 堆（Heap）:存放引用类型（如对象、数组、函数等），值大小不固定，栈内存中存放的地址指向堆内存中的对象； 堆是一种二叉树结构。它的存取数据的方式与书架非常相似。堆的特点是以“键值对”方式存储，存取方式和顺序无关

  1.  ![非线性表](https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg?wh=1142*727)

- 线性表（线性存储结构）：

  - 定义：把所有数据用一根线串起来，再存储到物理空间中。存储的是具有“一对一”关系的数据元素的集合。

  - 线性表常用术语：

    - 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
    - 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；

  - **线性表类型**：

    - 顺序表（数组实现）：将数据依次存储在连续的整块物理空间中。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，具有“一对一”特性。
    - 链表（指针/引用实现）：数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系。利用指针访问。
    - 散列表/哈希表 (Hash Table)：通过哈希函数将键映射到存储位置的数据结构。

    ```js
    // 顺序表（数组）
    const array = [1, 2, 3];
    array[1] = 5; // 随机访问修改

    // 链表
    class Node {
      constructor(value) {
        this.value = value;
        this.next = null;
      }
    }
    const head = new Node(1);
    head.next = new Node(2);

    // 散列表
    const map = new Map();
    map.set("key1", "value1"); // 基于哈希函数存储
    ```

  - 链表（Linked List）:

    - 定义：链表是一种线性数据结构，与数组不同，链表中的元素在内存中不是连续存储的，而是通过指针（在 JavaScript 中是引用）连接在一起(可以用对象模拟链表结构)。

      - 链表由一系列节点组成，每个节点包含：

        - 数据：存储的实际值
        - 指针/引用：指向下一个节点的引用（在双向链表中还有指向前一个节点的引用）

      - [链表的实现与应用](https://www.cnblogs.com/jaxu/p/11277732.html)

    - 链表的分类：

      1.  单向链表：链表中的每个元素都包含一个指向下一个元素的指针。
      2.  双向链表：链表中的每个元素都包含两个指针，一个指向下一个元素，一个指向上一个元素。
      3.  循环链表：链表的最后一个元素指向第一个元素，形成一个环。

- 树（Tree）:

  - [JS 树的实现](https://www.cnblogs.com/jaxu/p/11309385.html)

  - 树相关术语：（https://juejin.im/post/5ad56de7f265da2391489be3#heading-2）
    根结点是树最顶层结点
    边是两个结点之间的连接
    子结点是具有父结点的结点
    父结点是与子结点有连接的结点
    叶子结点是树中没有子结点的结点（树得末端）
    高度是从下往上数。
    深度是从根节点往下层级。
    节点的度：节点拥有的子树的个数。

  - 二叉树（Binary tree）：指树中的节点最多只能有两个子节点，一个是左子节点，一个是右子节点。左右子节点的顺序不能颠倒。即二叉树中不存在度大于 2 的节点树。二叉树的遍历有两种选择：

    - 深度优先搜索（Depth-First Search，DFS）：（前中后序是相对根节点而言）广度优先算法实践
      前序遍历：根节点优先，之后是左节点，最后是右节点。
      中序遍历：左节点优先，之后是根节点，最后是右节点。
      后序遍历：左节点优先，之后是右节点，最后是根节点。
    - 广度优先搜索（Breadth-First Search，BFS）：BFS 是一层层逐渐深入的遍历算法

  - 二叉搜索树（BST——Binary Search Tree）是二叉树的一种，它规定在左子节点上存储小（比父节点）的值，在右子节点上（比父节点）存储大（或等于）的值。
    自平衡二叉搜索树（AVL——Adelson-Velskii-Landi）。在 AVL 中，任何一个节点左右两棵子树的高度之差最多为 1，添加或移除节点时，AVL 树会尝试自平衡。对 AVL 树的操作和对 BST 树的操作一样，不同点在于我们还需要重新平衡 AVL 树
    红黑树也是一种自平衡二叉搜索树，但是它对其中的节点做了很多特殊的规定，使得在操作树节点的性能上要优于 AVL。

- 图（Graph）

## 资源总结

[顺序存储结构与链式存储结构优缺点](https://blog.csdn.net/li_wen01/article/details/82986015#)
